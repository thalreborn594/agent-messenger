{"version":3,"sources":["../src/client.ts","../src/crypto.ts","../src/utils.ts","../src/daemon.ts"],"sourcesContent":["import WebSocket from 'ws';\nimport { DID, Contact, ContactBook, MessageCallback, WSMessage } from './types';\nimport { generateKeyPair, deriveDID, extractPublicKeyFromDID, encryptMessage, decryptMessage } from './crypto';\nimport { getDataDir as getDefaultDataDir, sanitizeDID, formatTimestampForFile, getCurrentTimestamp, ensureDir, sleep } from './utils';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nconst CONTACTS_FILE = 'contacts.json';\nconst IDENTITY_FILE = 'identity.json';\nconst KEY_FILE = 'identity.key';\n\nexport class AgentClient {\n  private relayUrl: string;\n  private dataDir: string;\n  private privateKey: Uint8Array | null = null;\n  private publicKey: Uint8Array | null = null;\n  private did: DID | null = null;\n  private contacts: ContactBook = {};\n  private ws: WebSocket | null = null;\n  private messageCallback: MessageCallback | null = null;\n  private messageQueue: Array<{ to: DID; content: string; timestamp: string }> = [];\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 10;\n  private reconnectDelay = 2000; // Start at 2 seconds\n  private isConnecting = false;\n\n  constructor(relayUrl: string, dataDir?: string) {\n    this.relayUrl = relayUrl;\n    this.dataDir = dataDir || getDefaultDataDir();\n  }\n\n  /**\n   * Initialize agent identity and load contacts\n   */\n  async initialize(): Promise<void> {\n    ensureDir(this.dataDir);\n\n    // Load or create identity\n    await this.loadOrCreateIdentity();\n\n    // Load contacts\n    this.loadContacts();\n\n    console.log(`[agent] ‚úÖ Initialized`);\n    console.log(`[agent] DID: ${this.did}`);\n    console.log(`[agent] Contacts loaded: ${Object.keys(this.contacts).length}`);\n  }\n\n  /**\n   * Load existing identity or create new one\n   */\n  private async loadOrCreateIdentity(): Promise<void> {\n    const identityPath = path.join(this.dataDir, IDENTITY_FILE);\n    const keyPath = path.join(this.dataDir, KEY_FILE);\n\n    if (fs.existsSync(identityPath) && fs.existsSync(keyPath)) {\n      // Load existing identity\n      const identityInfo = JSON.parse(fs.readFileSync(identityPath, 'utf-8'));\n      const privateKeyBytes = fs.readFileSync(keyPath);\n      this.privateKey = new Uint8Array(privateKeyBytes);\n\n      // Derive public key from private\n      const { ed25519 } = await import('@noble/curves/ed25519');\n      this.publicKey = new Uint8Array(ed25519.getPublicKey(this.privateKey));\n\n      this.did = identityInfo.did as DID;\n\n      console.log(`[identity] ‚úÖ Loaded existing identity`);\n      console.log(`[identity] DID: ${this.did}`);\n    } else {\n      // Generate new identity\n      console.log(`[identity] üîë Generating new identity...`);\n\n      const keypair = generateKeyPair();\n      this.privateKey = keypair.privateKey;\n      this.publicKey = keypair.publicKey;\n      this.did = deriveDID(this.publicKey);\n\n      // Save key (binary)\n      fs.writeFileSync(keyPath, Buffer.from(this.privateKey));\n      fs.chmodSync(keyPath, 0o600); // Read/write for owner only\n\n      // Create identity info\n      const identityInfo = {\n        did: this.did,\n        keyType: 'Ed25519',\n        createdAt: getCurrentTimestamp(),\n        version: '3.0',\n      };\n\n      fs.writeFileSync(identityPath, JSON.stringify(identityInfo, null, 2));\n\n      console.log(`[identity] ‚úÖ New identity created`);\n      console.log(`[identity] DID: ${this.did}`);\n    }\n  }\n\n  /**\n   * Load contacts from file\n   */\n  private loadContacts(): void {\n    const contactsPath = path.join(this.dataDir, CONTACTS_FILE);\n\n    if (fs.existsSync(contactsPath)) {\n      this.contacts = JSON.parse(fs.readFileSync(contactsPath, 'utf-8'));\n    } else {\n      this.contacts = {};\n      this.saveContacts();\n    }\n  }\n\n  /**\n   * Save contacts to file\n   */\n  private saveContacts(): void {\n    const contactsPath = path.join(this.dataDir, CONTACTS_FILE);\n    ensureDir(this.dataDir);\n    fs.writeFileSync(contactsPath, JSON.stringify(this.contacts, null, 2));\n  }\n\n  /**\n   * Set callback for incoming messages\n   */\n  setMessageCallback(callback: MessageCallback): void {\n    this.messageCallback = callback;\n  }\n\n  /**\n   * Get this agent's DID\n   */\n  getDID(): DID | null {\n    return this.did;\n  }\n\n  /**\n   * Get contacts\n   */\n  getContacts(): ContactBook {\n    return { ...this.contacts };\n  }\n\n  /**\n   * Find contact by exact name match\n   */\n  findContactByName(name: string): DID | null {\n    const nameLower = name.toLowerCase();\n    for (const [did, info] of Object.entries(this.contacts)) {\n      if (info.name.toLowerCase() === nameLower) {\n        return did as DID;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Find contacts by fuzzy name matching\n   */\n  findContactsFuzzy(name: string, threshold = 0.3): Array<{ did: DID; name: string; score: number }> {\n    const nameLower = name.toLowerCase();\n    const matches: Array<{ did: DID; name: string; score: number }> = [];\n\n    for (const [did, info] of Object.entries(this.contacts)) {\n      const contactName = info.name.toLowerCase();\n      const ratio = this.calculateSimilarity(nameLower, contactName);\n\n      if (ratio >= threshold) {\n        matches.push({\n          did: did as DID,\n          name: info.name,\n          score: ratio,\n        });\n      }\n    }\n\n    // Sort by score descending\n    matches.sort((a, b) => b.score - a.score);\n    return matches;\n  }\n\n  /**\n   * Calculate similarity ratio between two strings (Levenshtein distance)\n   */\n  private calculateSimilarity(str1: string, str2: string): number {\n    if (str1 === str2) return 1;\n    if (str1.length === 0 || str2.length === 0) return 0;\n\n    const matrix: number[][] = Array(str2.length + 1)\n      .fill(null)\n      .map(() => Array(str1.length + 1).fill(null));\n\n    for (let i = 0; i <= str1.length; i++) {\n      matrix[0][i] = i;\n    }\n\n    for (let j = 0; j <= str2.length; j++) {\n      matrix[j][0] = j;\n    }\n\n    for (let j = 1; j <= str2.length; j++) {\n      for (let i = 1; i <= str1.length; i++) {\n        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;\n        matrix[j][i] = Math.min(\n          matrix[j][i - 1] + 1,\n          matrix[j - 1][i] + 1,\n          matrix[j - 1][i - 1] + indicator\n        );\n      }\n    }\n\n    const distance = matrix[str2.length][str1.length];\n    const maxLength = Math.max(str1.length, str2.length);\n    return 1 - distance / maxLength;\n  }\n\n  /**\n   * Add a contact\n   */\n  addContact(name: string, did: DID, notes = ''): void {\n    this.contacts[did] = {\n      name,\n      did,\n      addedAt: getCurrentTimestamp(),\n      notes,\n    };\n    this.saveContacts();\n    console.log(`[contacts] ‚úÖ Added: ${name} (${did.slice(0, 32)}...)`);\n  }\n\n  /**\n   * Get public key as base64 string (extracted from DID)\n   */\n  getPublicKeyBase64(): string {\n    if (!this.did) return '';\n    const pubkeyBytes = extractPublicKeyFromDID(this.did);\n    return Buffer.from(pubkeyBytes).toString('base64');\n  }\n\n  /**\n   * Connect to relay via WebSocket\n   */\n  async connect(): Promise<boolean> {\n    if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.OPEN)) {\n      return true;\n    }\n\n    this.isConnecting = true;\n    const wsUrl = this.relayUrl.replace(/\\/$/, '') + '/ws';\n\n    console.log(`[agent] üì° Connecting to relay...`);\n    console.log(`[agent] URL: ${wsUrl}`);\n\n    return new Promise((resolve) => {\n      this.ws = new WebSocket(wsUrl);\n\n      this.ws.on('open', () => {\n        if (!this.did) {\n          console.log('[agent] ‚ùå No DID available');\n          this.isConnecting = false;\n          resolve(false);\n          return;\n        }\n\n        // Send connect message with DID\n        const connectMsg: WSMessage = { type: 'connected', to: this.did };\n        this.ws!.send(JSON.stringify({ type: 'connect', did: this.did }));\n\n        console.log(`[agent] ‚úÖ Connected to relay`);\n        this.reconnectAttempts = 0;\n        this.reconnectDelay = 2000;\n        this.isConnecting = false;\n\n        // Start listening\n        this.listen();\n\n        // Send queued messages\n        this.processMessageQueue();\n\n        resolve(true);\n      });\n\n      this.ws.on('message', async (data) => {\n        try {\n          const message = JSON.parse(data.toString());\n\n          if (message.error) {\n            console.log(`[agent] ‚ö†Ô∏è  Relay error: ${message.error}`);\n            return;\n          }\n\n          if (message.type === 'message' && message.content) {\n            await this.handleIncomingMessage(message);\n          }\n        } catch (error) {\n          console.log(`[agent] ‚ùå Error handling message: ${error}`);\n        }\n      });\n\n      this.ws.on('close', () => {\n        console.log(`[agent] üîå Disconnected from relay`);\n        this.ws = null;\n        this.isConnecting = false;\n\n        // Auto-reconnect\n        this.scheduleReconnect();\n      });\n\n      this.ws.on('error', (error) => {\n        console.log(`[agent] ‚ùå WebSocket error: ${error}`);\n        this.isConnecting = false;\n        resolve(false);\n      });\n    });\n  }\n\n  /**\n   * Schedule reconnection attempt\n   */\n  private scheduleReconnect(): void {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.log(`[agent] ‚ùå Max reconnect attempts reached`);\n      return;\n    }\n\n    this.reconnectAttempts++;\n    const delay = this.reconnectDelay;\n    this.reconnectDelay = Math.min(this.reconnectDelay * 2, 60000); // Cap at 60 seconds\n\n    console.log(`[agent] üîÅ Reconnecting in ${delay / 1000}s (attempt ${this.reconnectAttempts})`);\n\n    setTimeout(() => {\n      this.connect();\n    }, delay);\n  }\n\n  /**\n   * Handle incoming message\n   */\n  private async handleIncomingMessage(message: WSMessage): Promise<void> {\n    const senderDID = message.from;\n    const encryptedB64 = message.content;\n\n    if (!senderDID || !encryptedB64) {\n      console.log(`[agent] ‚ö†Ô∏è  Invalid message format`);\n      return;\n    }\n\n    console.log(`\\n[agent] üì¨ Message received!`);\n    console.log(`[agent] From: ${senderDID.slice(0, 32)}...`);\n\n    try {\n      // Get sender's public key from their DID\n      const senderPublicKey = extractPublicKeyFromDID(senderDID);\n\n      // Decrypt\n      const plaintext = decryptMessage(encryptedB64, senderPublicKey);\n\n      console.log(`[agent] Content: ${plaintext}`);\n\n      // Save to local file\n      this.saveMessage(senderDID, plaintext, message.timestamp);\n\n      // Notify callback if set\n      if (this.messageCallback) {\n        this.messageCallback(senderDID, plaintext, message.timestamp);\n      }\n    } catch (error) {\n      console.log(`[agent] ‚ùå Decryption failed: ${error}`);\n    }\n  }\n\n  /**\n   * Listen for incoming messages (already handled in connect())\n   */\n  private listen(): void {\n    console.log(`[agent] üëÇ Listening for messages...`);\n  }\n\n  /**\n   * Process queued messages\n   */\n  private async processMessageQueue(): Promise<void> {\n    while (this.messageQueue.length > 0) {\n      const msg = this.messageQueue.shift();\n      if (msg) {\n        await this.sendMessage(msg.to, msg.content);\n      }\n    }\n  }\n\n  /**\n   * Send message to recipient\n   */\n  async sendMessage(recipientDID: DID, content: string): Promise<boolean> {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.log(`[agent] ‚ùå Not connected, queuing message`);\n      this.messageQueue.push({\n        to: recipientDID,\n        content,\n        timestamp: getCurrentTimestamp(),\n      });\n      return false;\n    }\n\n    if (!(recipientDID in this.contacts)) {\n      console.log(`[agent] ‚ùå Recipient not in contacts: ${recipientDID}`);\n      return false;\n    }\n\n    if (!recipientDID.startsWith('did:key:ed25519:')) {\n      console.log(`[agent] ‚ùå Unsupported DID format`);\n      return false;\n    }\n\n    // Get recipient's public key\n    const recipientPublicKey = extractPublicKeyFromDID(recipientDID);\n\n    console.log(`[agent] üîí Encrypting message for ${this.contacts[recipientDID].name}...`);\n\n    // Encrypt\n    const encryptedB64 = encryptMessage(content, recipientPublicKey);\n\n    // Send via relay\n    const messageData: WSMessage = {\n      type: 'message',\n      to: recipientDID,\n      content: encryptedB64,\n    };\n\n    try {\n      this.ws.send(JSON.stringify(messageData));\n      console.log(`[agent] ‚úÖ Message sent to ${this.contacts[recipientDID].name}`);\n      return true;\n    } catch (error) {\n      console.log(`[agent] ‚ùå Send failed: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Save message to local file\n   */\n  private saveMessage(senderDID: DID, content: string, timestamp?: string): void {\n    const messagesDir = path.join(this.dataDir, 'messages');\n    ensureDir(messagesDir);\n\n    const safeDID = sanitizeDID(senderDID);\n    const timestampStr = formatTimestampForFile(timestamp);\n    const filename = `${timestampStr}_${safeDID}.json`;\n    const filepath = path.join(messagesDir, filename);\n\n    const messageRecord = {\n      from: senderDID,\n      content,\n      timestamp: timestamp || getCurrentTimestamp(),\n      savedAt: getCurrentTimestamp(),\n    };\n\n    fs.writeFileSync(filepath, JSON.stringify(messageRecord, null, 2));\n    console.log(`[agent] üíæ Saved: ${filepath}`);\n  }\n\n  /**\n   * Get saved messages\n   */\n  getMessages(limit = 50, fromDID?: string): Array<{ from: DID; content: string; timestamp: string; savedAt: string }> {\n    const messagesDir = path.join(this.dataDir, 'messages');\n\n    if (!fs.existsSync(messagesDir)) {\n      return [];\n    }\n\n    const messageFiles = fs.readdirSync(messagesDir)\n      .filter(f => f.endsWith('.json'))\n      .sort()\n      .reverse()\n      .slice(0, limit);\n\n    const messages: Array<{ from: DID; content: string; timestamp: string; savedAt: string }> = [];\n\n    for (const filename of messageFiles) {\n      const filepath = path.join(messagesDir, filename);\n      const msg = JSON.parse(fs.readFileSync(filepath, 'utf-8'));\n\n      if (fromDID) {\n        // Filter by sender\n        const fromLower = fromDID.toLowerCase();\n        const msgFrom = msg.from.toLowerCase();\n        if (!msgFrom.includes(fromLower)) {\n          continue;\n        }\n      }\n\n      messages.push(msg);\n    }\n\n    return messages;\n  }\n\n  /**\n   * Disconnect from relay\n   */\n  disconnect(): void {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n\n  /**\n   * Check if connected\n   */\n  isConnected(): boolean {\n    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;\n  }\n}\n","import { ed25519 } from '@noble/curves/ed25519';\nimport { chacha20poly1305 } from '@noble/ciphers/chacha';\nimport { hkdfSync } from 'crypto';\nimport { KeyPair, DID } from './types';\nimport { base64UrlEncode, base64UrlDecode } from './utils';\nimport * as zlib from 'zlib';\n\nconst HKDF_INFO = Buffer.from('agent-messenger-v2');\nconst NONCE = Buffer.from('agent-messenger-v2').slice(0, 12); // First 12 bytes\n\n/**\n * Generate Ed25519 key pair\n */\nexport function generateKeyPair(): KeyPair {\n  const privateKey = ed25519.utils.randomPrivateKey();\n  const publicKey = ed25519.getPublicKey(privateKey);\n\n  return {\n    privateKey: new Uint8Array(privateKey),\n    publicKey: new Uint8Array(publicKey),\n  };\n}\n\n/**\n * Derive DID from public key\n * Format: did:key:ed25519:BASE64_URLSAFE_NO_PADDING\n */\nexport function deriveDID(publicKey: Uint8Array): DID {\n  const pubkeyB64 = base64UrlEncode(publicKey);\n  return `did:key:ed25519:${pubkeyB64}` as DID;\n}\n\n/**\n * Sign message with private key\n */\nexport function signMessage(privateKey: Uint8Array, message: Uint8Array): Uint8Array {\n  const signature = ed25519.sign(message, privateKey);\n  return new Uint8Array(signature);\n}\n\n/**\n * Verify signature with public key\n */\nexport function verifySignature(\n  publicKey: Uint8Array,\n  message: Uint8Array,\n  signature: Uint8Array\n): boolean {\n  try {\n    return ed25519.verify(signature, message, publicKey);\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Derive shared key using HKDF\n * Uses recipient's public key as input material\n */\nexport function deriveSharedKey(recipientPublicKey: Uint8Array): Uint8Array {\n  const sharedKey = hkdfSync('sha256', Buffer.from(recipientPublicKey), Buffer.alloc(0), Buffer.from(HKDF_INFO), 32);\n  return new Uint8Array(sharedKey);\n}\n\n/**\n * Extract public key from DID\n */\nexport function extractPublicKeyFromDID(did: DID): Uint8Array {\n  if (!did.startsWith('did:key:ed25519:')) {\n    throw new Error('Invalid DID format');\n  }\n\n  const b64Part = did.split('did:key:ed25519:')[1];\n  return base64UrlDecode(b64Part);\n}\n\n/**\n * Compress data using zlib\n */\nexport function compress(data: Uint8Array): Uint8Array {\n  return new Uint8Array(zlib.deflateSync(data));\n}\n\n/**\n * Decompress data using zlib\n */\nexport function decompress(data: Uint8Array): Uint8Array {\n  return new Uint8Array(zlib.inflateSync(data));\n}\n\n/**\n * Encrypt message for recipient\n * Returns: base64-encoded ciphertext\n */\nexport function encryptMessage(\n  plaintext: string,\n  recipientPublicKey: Uint8Array\n): string {\n  // Derive shared key\n  const sharedKey = deriveSharedKey(recipientPublicKey);\n\n  // Compress plaintext\n  const plaintextBytes = Buffer.from(plaintext, 'utf-8');\n  const compressed = compress(plaintextBytes);\n\n  // Encrypt with ChaCha20-Poly1305\n  const cipher = chacha20poly1305(sharedKey, NONCE);\n  const ciphertext = cipher.encrypt(compressed);\n\n  // Encode as base64 (standard base64, not URL-safe - matches Python)\n  const encryptedB64 = Buffer.from(ciphertext).toString('base64');\n\n  return encryptedB64;\n}\n\n/**\n * Decrypt message from sender\n * Returns: plaintext string\n */\nexport function decryptMessage(\n  encryptedB64: string,\n  senderPublicKey: Uint8Array\n): string {\n  // Decode from base64\n  const ciphertext = Buffer.from(encryptedB64, 'base64');\n\n  // Derive shared key\n  const sharedKey = deriveSharedKey(senderPublicKey);\n\n  // Decrypt with ChaCha20-Poly1305\n  const cipher = chacha20poly1305(sharedKey, NONCE);\n  const compressed = cipher.decrypt(ciphertext);\n\n  // Decompress\n  const plaintextBytes = decompress(compressed);\n  const plaintext = Buffer.from(plaintextBytes).toString('utf-8');\n\n  return plaintext;\n}\n","/**\n * Utility functions for Agent Messenger v3.0\n * - File I/O operations\n * - Data directory management\n * - OS-specific paths\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\nimport type { KeyPair, DID, ContactBook, StoredMessage, IdentityStorage } from './types';\nimport { generateKeyPair, deriveDID } from './crypto';\n\n/**\n * Get platform-specific data directory\n */\nexport function getDataDir(customDir?: string): string {\n  if (customDir) {\n    return customDir;\n  }\n\n  const platform = os.platform();\n  const homeDir = os.homedir();\n\n  switch (platform) {\n    case 'win32':\n      return path.join(process.env.APPDATA || path.join(homeDir, 'AppData', 'Roaming'), 'agent-messenger');\n    case 'darwin':\n      return path.join(homeDir, '.agent-messenger');\n    default: // linux, freebsd, etc.\n      return path.join(homeDir, '.agent-messenger');\n  }\n}\n\n/**\n * Ensure directory exists, create if not\n */\nexport function ensureDir(dirPath: string): void {\n  if (!fs.existsSync(dirPath)) {\n    fs.mkdirSync(dirPath, { recursive: true, mode: 0o700 });\n  }\n}\n\n/**\n * Read JSON file safely\n */\nexport function readJSON<T>(filePath: string): T | null {\n  try {\n    const data = fs.readFileSync(filePath, 'utf8');\n    return JSON.parse(data) as T;\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Write JSON file safely\n */\nexport function writeJSON<T>(filePath: string, data: T): void {\n  const dir = path.dirname(filePath);\n  ensureDir(dir);\n\n  fs.writeFileSync(filePath, JSON.stringify(data, null, 2), {\n    encoding: 'utf8',\n    mode: 0o600,\n  });\n}\n\n/**\n * Save Ed25519 keypair to disk\n * - identity.key: binary private key (0o600)\n * - identity.json: public identity metadata\n */\nexport function saveKeypair(\n  dataDir: string,\n  keypair: KeyPair,\n  did: DID\n): void {\n  const keyPath = path.join(dataDir, 'identity.key');\n  const jsonPath = path.join(dataDir, 'identity.json');\n\n  // Save private key (binary, restricted permissions)\n  ensureDir(dataDir);\n  fs.writeFileSync(keyPath, Buffer.from(keypair.privateKey), {\n    mode: 0o600,\n  });\n\n  // Save public identity\n  const identity: IdentityStorage = {\n    did,\n    public_key_b64: Buffer.from(keypair.publicKey).toString('base64'),\n    created_at: new Date().toISOString(),\n  };\n\n  writeJSON(jsonPath, identity);\n}\n\n/**\n * Load Ed25519 keypair from disk\n */\nexport function loadKeypair(dataDir: string): { keypair: KeyPair; did: DID } | null {\n  try {\n    const keyPath = path.join(dataDir, 'identity.key');\n    const jsonPath = path.join(dataDir, 'identity.json');\n\n    // Load private key\n    const privateKey = fs.readFileSync(keyPath);\n\n    // Load public identity\n    const identity = readJSON<IdentityStorage>(jsonPath);\n\n    if (!identity) {\n      return null;\n    }\n\n    // Derive public key from private key\n    const { ed25519 } = require('@noble/curves/ed25519');\n    const publicKey = ed25519.getPublicKey(privateKey);\n\n    const keypair: KeyPair = {\n      publicKey,\n      privateKey: new Uint8Array(privateKey),\n    };\n\n    return {\n      keypair,\n      did: identity.did,\n    };\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Get or create keypair\n */\nexport function getOrCreateKeypair(dataDir: string): { keypair: KeyPair; did: DID } {\n  const existing = loadKeypair(dataDir);\n\n  if (existing) {\n    return existing;\n  }\n\n  // Generate new keypair\n  const keypair = generateKeyPair();\n  const did = deriveDID(keypair.publicKey);\n\n  // Save to disk\n  saveKeypair(dataDir, keypair, did);\n\n  return { keypair, did };\n}\n\n/**\n * Load contacts from contacts.json\n */\nexport function loadContacts(dataDir: string): ContactBook {\n  const contactsPath = path.join(dataDir, 'contacts.json');\n  const contacts = readJSON<ContactBook>(contactsPath);\n\n  return contacts || {};\n}\n\n/**\n * Save contacts to contacts.json\n */\nexport function saveContacts(dataDir: string, contacts: ContactBook): void {\n  const contactsPath = path.join(dataDir, 'contacts.json');\n  writeJSON(contactsPath, contacts);\n}\n\n/**\n * Sanitize DID for use in filename\n * Keeps only alphanumeric characters and underscores\n */\nexport function sanitizeDID(did: DID): string {\n  return did.replace(/[^a-zA-Z0-9_]/g, '_');\n}\n\n/**\n * Save message to disk\n * Format: messages/{timestamp}_{sanitized_did}.json\n */\nexport function saveMessage(\n  dataDir: string,\n  from: DID,\n  content: string,\n  timestamp?: string\n): void {\n  const messagesDir = path.join(dataDir, 'messages');\n  ensureDir(messagesDir);\n\n  const msgTimestamp = timestamp || new Date().toISOString();\n  const sanitized = sanitizeDID(from);\n  const filename = `${msgTimestamp.replace(/[^0-9]/g, '')}_${sanitized}.json`;\n  const filePath = path.join(messagesDir, filename);\n\n  const message: StoredMessage = {\n    from,\n    content,\n    timestamp: msgTimestamp,\n    savedAt: new Date().toISOString(),\n  };\n\n  writeJSON(filePath, message);\n}\n\n/**\n * List all messages from disk\n */\nexport function listMessages(\n  dataDir: string,\n  options: { limit?: number; from?: DID } = {}\n): StoredMessage[] {\n  const messagesDir = path.join(dataDir, 'messages');\n\n  if (!fs.existsSync(messagesDir)) {\n    return [];\n  }\n\n  const files = fs.readdirSync(messagesDir)\n    .filter(f => f.endsWith('.json'))\n    .sort()\n    .reverse(); // Newest first\n\n  const messages: StoredMessage[] = [];\n\n  for (const file of files) {\n    if (options.limit && messages.length >= options.limit) {\n      break;\n    }\n\n    const filePath = path.join(messagesDir, file);\n    const message = readJSON<StoredMessage>(filePath);\n\n    if (message) {\n      // Filter by sender if specified\n      if (options.from && message.from !== options.from) {\n        continue;\n      }\n\n      messages.push(message);\n    }\n  }\n\n  return messages;\n}\n\n/**\n * Find contact by name or DID\n */\nexport function findContact(\n  dataDir: string,\n  nameOrDID: string\n): { did: DID; contact: any } | null {\n  const contacts = loadContacts(dataDir);\n\n  // Try exact DID match\n  if (contacts[nameOrDID as DID]) {\n    return {\n      did: nameOrDID as DID,\n      contact: contacts[nameOrDID as DID],\n    };\n  }\n\n  // Try name match (case-insensitive)\n  for (const [did, contact] of Object.entries(contacts)) {\n    if (contact.name.toLowerCase() === nameOrDID.toLowerCase()) {\n      return { did: did as DID, contact };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get lock file path\n */\nexport function getLockFilePath(dataDir: string): string {\n  return path.join(dataDir, 'daemon.lock');\n}\n\n/**\n * Check if daemon is running (lock file exists)\n */\nexport function isDaemonRunning(dataDir: string): boolean {\n  const lockPath = getLockFilePath(dataDir);\n  return fs.existsSync(lockPath);\n}\n\n/**\n * Create lock file\n */\nexport function createLockFile(dataDir: string, pid: number): void {\n  const lockPath = getLockFilePath(dataDir);\n  fs.writeFileSync(lockPath, pid.toString(), { mode: 0o600 });\n}\n\n/**\n * Remove lock file\n */\nexport function removeLockFile(dataDir: string): void {\n  const lockPath = getLockFilePath(dataDir);\n\n  if (fs.existsSync(lockPath)) {\n    fs.unlinkSync(lockPath);\n  }\n}\n\n/**\n * Get current timestamp in ISO 8601 format\n */\nexport function getTimestamp(): string {\n  return new Date().toISOString();\n}\n\n/**\n * Validate DID format\n */\nexport function isValidDID(did: string): boolean {\n  return did.startsWith('did:key:ed25519:');\n}\n\n/**\n * Parse username from @username format\n */\nexport function parseUsername(username: string): string {\n  if (username.startsWith('@')) {\n    return username.slice(1);\n  }\n  return username;\n}\n\n/**\n * Format username with @ prefix\n */\nexport function formatUsername(username: string): string {\n  if (username.startsWith('@')) {\n    return username;\n  }\n  return `@${username}`;\n}\n\n/**\n * Base64 URL-safe encoding (no padding)\n */\nexport function base64UrlEncode(data: Uint8Array): string {\n  const base64 = Buffer.from(data).toString('base64');\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n}\n\n/**\n * Base64 URL-safe decoding\n */\nexport function base64UrlDecode(str: string): Uint8Array {\n  let base64 = str.replace(/-/g, '+').replace(/_/g, '/');\n\n  // Add padding if needed\n  while (base64.length % 4 !== 0) {\n    base64 += '=';\n  }\n\n  return new Uint8Array(Buffer.from(base64, 'base64'));\n}\n\n/**\n * Format timestamp for filename\n */\nexport function formatTimestampForFile(timestamp?: string): string {\n  if (timestamp) {\n    return timestamp.replace(/[:.]/g, '-');\n  }\n  const now = new Date();\n  const year = now.getFullYear();\n  const month = String(now.getMonth() + 1).padStart(2, '0');\n  const day = String(now.getDate()).padStart(2, '0');\n  const hour = String(now.getHours()).padStart(2, '0');\n  const minute = String(now.getMinutes()).padStart(2, '0');\n  const second = String(now.getSeconds()).padStart(2, '0');\n  return `${year}${month}${day}_${hour}${minute}${second}`;\n}\n\n/**\n * Get current ISO timestamp\n */\nexport function getCurrentTimestamp(): string {\n  return new Date().toISOString();\n}\n\n/**\n * Sleep utility\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Validate username format\n */\nexport function validateUsername(username: string): boolean {\n  return /^@[a-zA-Z0-9_]{2,19}$/.test(username);\n}\n","import express, { Request, Response, Router } from 'express';\nimport { AgentClient } from './client';\nimport { DID, SendMessageRequest, AddContactRequest, RegisterRequest, DirectoryResponse, Status } from './types';\nimport { getDataDir as getDefaultDataDir, validateUsername } from './utils';\nimport axios from 'axios';\nimport { createWriteStream, existsSync, mkdirSync, readFileSync, readdirSync, rmdirSync, unlinkSync } from 'fs';\nimport { join } from 'path';\n\nconst DEFAULT_API_PORT = 5757;\nconst LOCK_FILE = 'daemon.lock';\n\nexport class AgentDaemon {\n  private client: AgentClient;\n  private app: express.Application;\n  private port: number;\n  private host: string;\n  private dataDir: string;\n  private profile?: string;\n  private lockFilePath: string;\n\n  constructor(relayUrl: string, dataDir?: string, apiPort = DEFAULT_API_PORT, apiHost = '127.0.0.1', profile?: string) {\n    // Determine data directory\n    if (dataDir) {\n      this.dataDir = dataDir;\n    } else if (profile) {\n      this.dataDir = join(getDefaultDataDir(), 'profiles', profile);\n    } else {\n      this.dataDir = getDefaultDataDir();\n    }\n\n    this.port = apiPort;\n    this.host = apiHost;\n    this.profile = profile;\n    this.lockFilePath = join(this.dataDir, LOCK_FILE);\n\n    // Create client\n    this.client = new AgentClient(relayUrl, this.dataDir);\n\n    // Create Express app\n    this.app = express();\n    this.app.use(express.json());\n\n    // Setup routes\n    this.setupRoutes();\n  }\n\n  /**\n   * Setup HTTP API routes\n   */\n  private setupRoutes(): void {\n    // Root endpoint\n    this.app.get('/', (req: Request, res: Response) => {\n      res.json({\n        service: 'Agent Messenger Daemon',\n        version: '3.0',\n        status: 'running',\n        did: this.client.getDID(),\n        connected: this.client.isConnected(),\n        dataDir: this.dataDir,\n      });\n    });\n\n    // Status endpoint\n    this.app.get('/status', (req: Request, res: Response) => {\n      const contacts = this.client.getContacts();\n      const messages = this.client.getMessages();\n\n      const status: Status = {\n        did: this.client.getDID() || '',\n        relay: this.client['relayUrl'] || '',\n        connected: this.client.isConnected(),\n        contacts: Object.keys(contacts).length,\n        messages: messages.length,\n        dataDir: this.dataDir,\n        profile: this.profile || 'default',\n      };\n\n      res.json(status);\n    });\n\n    // Send message endpoint\n    this.app.post('/send', async (req: Request, res: Response) => {\n      try {\n        const { to, toName, content } = req.body as SendMessageRequest;\n\n        if (!content) {\n          return res.status(400).json({ detail: 'Content is required' });\n        }\n\n        if (!to && !toName) {\n          return res.status(400).json({ detail: 'Must specify to or to_name' });\n        }\n\n        // Resolve recipient\n        let recipientDID: DID | null = null;\n\n        if (to) {\n          recipientDID = to;\n        } else if (toName) {\n          // Try exact match first\n          recipientDID = this.client.findContactByName(toName);\n\n          // If no exact match, try fuzzy search\n          if (!recipientDID) {\n            const matches = this.client.findContactsFuzzy(toName);\n\n            if (matches.length > 0) {\n              return res.status(300).json({\n                status: 'ambiguous_name',\n                message: `No exact match for '${toName}'. Did you mean:`,\n                suggestions: matches.slice(0, 3).map(\n                  m => `${m.name} (DID: ${m.did}, similarity: ${Math.round(m.score * 100)}%)`\n                ),\n              });\n            } else {\n              return res.status(404).json({ detail: `Contact not found: ${toName}` });\n            }\n          }\n        }\n\n        if (!recipientDID) {\n          return res.status(400).json({ detail: 'Could not resolve recipient' });\n        }\n\n        const success = await this.client.sendMessage(recipientDID, content);\n\n        if (success) {\n          res.json({ status: 'sent', to: recipientDID, toName });\n        } else {\n          res.status(500).json({ detail: 'Failed to send message' });\n        }\n      } catch (error) {\n        res.status(500).json({ detail: `Error: ${error}` });\n      }\n    });\n\n    // Add contact endpoint\n    this.app.post('/add-contact', (req: Request, res: Response) => {\n      try {\n        const { did, name, notes = '' } = req.body as AddContactRequest;\n\n        if (!did || !name) {\n          return res.status(400).json({ detail: 'DID and name are required' });\n        }\n\n        this.client.addContact(name, did, notes);\n\n        res.json({ status: 'added', did, name });\n      } catch (error) {\n        res.status(500).json({ detail: `Error: ${error}` });\n      }\n    });\n\n    // List contacts endpoint\n    this.app.get('/contacts', (req: Request, res: Response) => {\n      try {\n        const contacts = this.client.getContacts();\n        const contactsList = Object.values(contacts);\n\n        res.json({ contacts: contactsList });\n      } catch (error) {\n        res.status(500).json({ detail: `Error: ${error}` });\n      }\n    });\n\n    // List messages endpoint\n    this.app.get('/messages', (req: Request, res: Response) => {\n      try {\n        const limit = typeof req.query.limit === 'string' ? parseInt(req.query.limit, 10) : 50;\n        const from = req.query.from as string | undefined;\n\n        const messages = this.client.getMessages(limit, from);\n\n        res.json({ messages, count: messages.length });\n      } catch (error) {\n        res.status(500).json({ detail: `Error: ${error}` });\n      }\n    });\n\n    // Disconnect endpoint\n    this.app.post('/disconnect', (req: Request, res: Response) => {\n      this.client.disconnect();\n      res.json({ status: 'disconnected' });\n    });\n\n    // Reconnect endpoint\n    this.app.post('/reconnect', async (req: Request, res: Response) => {\n      try {\n        const success = await this.client.connect();\n\n        if (success) {\n          res.json({ status: 'connected' });\n        } else {\n          res.status(500).json({ detail: 'Failed to connect' });\n        }\n      } catch (error) {\n        res.status(500).json({ detail: `Error: ${error}` });\n      }\n    });\n\n    // Directory endpoints\n    this.app.post('/register', async (req: Request, res: Response) => {\n      try {\n        const { username, description = '', purpose = '', tags = [] } = req.body as RegisterRequest;\n\n        if (!username) {\n          return res.status(400).json({ detail: 'Username is required' });\n        }\n\n        // Validate username format\n        if (!validateUsername(username)) {\n          return res.status(400).json({\n            detail:\n              'Invalid username format. Must start with @, 3-20 chars, alphanumeric + underscore only',\n          });\n        }\n\n        const did = this.client.getDID();\n        if (!did) {\n          return res.status(503).json({ detail: 'DID not available' });\n        }\n\n        // Build registration data\n        const data = {\n          username,\n          did,\n          publicKey: this.client.getPublicKeyBase64(),\n          description,\n          purpose,\n          tags,\n        };\n\n        // Register with relay\n        const relayHttpUrl = this.client['relayUrl'].replace('ws://', 'http://').replace('wss://', 'https://').replace('/ws', '');\n\n        const response = await axios.post(`${relayHttpUrl}/directory/register`, data);\n\n        if (response.status === 200) {\n          res.json({\n            status: 'registered',\n            message: `Registered username '${username}' in directory`,\n            username,\n            did: response.data.did,\n          });\n        } else if (response.status === 409) {\n          res.status(409).json({ detail: response.data.detail || 'Username already taken' });\n        } else {\n          res.status(500).json({ detail: `Registration failed: ${response.data.detail || 'Unknown error'}` });\n        }\n      } catch (error) {\n        if (axios.isAxiosError(error)) {\n          if (error.response?.status === 409) {\n            return res.status(409).json({ detail: error.response.data.detail || 'Username already taken' });\n          }\n          return res.status(500).json({ detail: `Registration error: ${error.message}` });\n        }\n        res.status(500).json({ detail: `Error: ${error}` });\n      }\n    });\n\n    this.app.get('/directory', async (req: Request, res: Response) => {\n      try {\n        const search = req.query.search as string | undefined;\n\n        const relayHttpUrl = this.client['relayUrl'].replace('ws://', 'http://').replace('wss://', 'https://').replace('/ws', '');\n\n        const params: Record<string, string> = {};\n        if (search) {\n          params.search = search;\n        }\n\n        const response = await axios.get(`${relayHttpUrl}/directory`, { params });\n\n        if (response.status === 200) {\n          res.json(response.data as DirectoryResponse);\n        } else {\n          res.status(500).json({ detail: `Query failed: ${response.statusText}` });\n        }\n      } catch (error) {\n        if (axios.isAxiosError(error)) {\n          res.status(500).json({ detail: `Query error: ${error.message}` });\n        } else {\n          res.status(500).json({ detail: `Error: ${error}` });\n        }\n      }\n    });\n  }\n\n  /**\n   * Acquire lock file to prevent multiple instances\n   */\n  private acquireLock(): boolean {\n    mkdirSync(this.dataDir, { recursive: true });\n\n    try {\n      // Try to create lock file exclusively\n      writeFileSync(this.lockFilePath, process.pid.toString(), { flag: 'wx' });\n      console.log(`[daemon] üîí Lock acquired for profile: ${this.dataDir}`);\n      return true;\n    } catch (error) {\n      // Lock file exists, check if process is running\n      try {\n        const pid = parseInt(readFileSync(this.lockFilePath, 'utf-8').trim(), 10);\n\n        // Try to send signal 0 to check if process exists\n        process.kill(pid, 0);\n        console.log(`[daemon] ‚ùå Another instance is already running (PID: ${pid})`);\n        return false;\n      } catch {\n        // Process is dead, remove stale lock\n        unlinkSync(this.lockFilePath);\n        return this.acquireLock();\n      }\n    }\n  }\n\n  /**\n   * Release lock file\n   */\n  private releaseLock(): void {\n    if (existsSync(this.lockFilePath)) {\n      unlinkSync(this.lockFilePath);\n    }\n  }\n\n  /**\n   * Start the daemon\n   */\n  async start(): Promise<void> {\n    // Acquire lock\n    if (!this.acquireLock()) {\n      process.exit(1);\n    }\n\n    // Initialize client\n    await this.client.initialize();\n\n    // Connect to relay\n    const connected = await this.client.connect();\n\n    if (!connected) {\n      console.log('[daemon] ‚ùå Failed to connect to relay');\n      this.releaseLock();\n      process.exit(1);\n    }\n\n    // Start HTTP server\n    this.app.listen(this.port, this.host, () => {\n      console.log(`[daemon] ‚úÖ Daemon started`);\n      console.log(`[daemon] Relay: ${this.client['relayUrl']}`);\n      console.log(`[daemon] API: http://${this.host}:${this.port}`);\n      console.log(`[daemon] DID: ${this.client.getDID()}`);\n    });\n\n    // Handle shutdown\n    process.on('SIGINT', () => {\n      console.log('[daemon] ‚èπÔ∏è  Shutting down...');\n      this.client.disconnect();\n      this.releaseLock();\n      process.exit(0);\n    });\n\n    process.on('SIGTERM', () => {\n      console.log('[daemon] ‚èπÔ∏è  Shutting down...');\n      this.client.disconnect();\n      this.releaseLock();\n      process.exit(0);\n    });\n  }\n}\n\n// Helper function to write file with exclusive flag\nfunction writeFileSync(path: string, data: string, options?: { flag?: string }): void {\n  const fs = require('fs');\n  fs.writeFileSync(path, data, options);\n}\n"],"mappings":"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","names":["platform","ed25519","fs","path","ed25519","existsSync","mkdirSync","readFileSync","unlinkSync","join","writeFileSync","path","fs"]}